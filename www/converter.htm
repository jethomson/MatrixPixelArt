<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Image Converter</title>
    <style>
        .box {
          border: 2px solid #fff;
        }

        body {
          font-family: Arial, sans-serif;
          color: #faffff;
          background: #111;
          font-size: 17px;
          text-align: center;
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: transparent;
        }

        #return_main_menu {
          float: left;
        }

        .top-part {
          width: 600px;
          margin: 0 auto;
        }
        .container {
          max-width: 100% -40px;
          border-radius: 0px;
          padding: 20px;
          text-align: center;
        }

        p {
          font-size: 1em;
          color: #777;
          line-height: 1.5;
          font-family: Arial, sans-serif;
        }

        #fieldTable {
          font-size: 1  em;
          color: #777;
          line-height: 1;
          font-family: Arial, sans-serif;
        }

        #scaleTable {
          font-size: 1  em;
          color: #777;
          line-height: 1;
          font-family: Arial, sans-serif;
        }

        #drop-zone {
          display: block;
          width: 100%-40px;
          border: 3px dashed #ddd;
          border-radius: 0px;
          text-align: center;
          padding: 20px;
          margin: 0px;
          cursor: pointer;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #777;
        }

        #file-picker {
          display: none;
        }
        .adaptiveTD{
          display: flex;
          flex-direction: row;
          flex-wrap: nowrap;
          align-items: center;

        }

        .mainSelector {
          background-color: #222;
          color: #ddd;
          border: 1px solid #333;
          margin-top: 4px;
          margin-bottom: 4px;
          padding: 0 8px;
          height: 28px;
          font-size: 15px;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .adaptiveSelector {
          background-color: #222;
          color: #ddd;
          border: 1px solid #333;
          margin-top: 4px;
          margin-bottom: 4px;
          padding: 0 8px;
          height: 28px;
          font-size: 15px;
          border-radius: 7px;
          flex-grow: 1;
          display: none;
        }

        .segmentsDiv{
          width: 36px;
          padding-left: 5px;
        }

        * input[type=range] {
          appearance: none;
          -moz-appearance: none;
          -webkit-appearance: none;
          flex-grow: 1;
          padding: 0;
          margin: 4px 8px 4px 0;
          background-color: transparent;
          cursor: pointer;
          background: linear-gradient(to right, #bbb 50%, #333 50%);
          border-radius: 7px;
        }

        input[type=range]:focus {
          outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
          height: 28px;
          cursor: pointer;
          background: transparent;
          border-radius: 7px;
        }
        input[type=range]::-webkit-slider-thumb {
          height: 16px;
          width: 16px;
          border-radius: 50%;
          background: #fff;
          cursor: pointer;
          -webkit-appearance: none;
          margin-top: 4px;
          border-radius: 7px;
        }
        input[type=range]::-moz-range-track {
          height: 28px;
          background-color: rgba(0, 0, 0, 0);
          border-radius: 7px;
        }
        input[type=range]::-moz-range-thumb {
          border: 0px solid rgba(0, 0, 0, 0);
          height: 16px;
          width: 16px;
          border-radius: 7px;
          background: #fff;
        }

        .rangeNumber{
          width: 20px;
          vertical-align: middle;
        }

        .fullTextField[type=text] {
          background-color: #222;
          border: 1px solid #333;
          padding-inline-start: 5px;
          margin-top: 4px;
          margin-bottom: 4px;
          height: 24px;
          border-radius: 0px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .flxTFld{
          background-color: #222;
          border: 1px solid #333;
          padding-inline-start: 5px;
          height: 24px;
          border-radius: 0px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        * input[type=submit] {
          background-color: #222;
          border: 1px solid #333;
          padding: 0.5em;
          width: 100%;
          border-radius: 24px;
          font-family: Arial, sans-serif;
          font-size: 1.3em;
          color: #ddd;
        }

        * button {
          background-color: #222;
          border: 1px solid #333;
          padding-inline: 5px;
          width: 100%;
          border-radius: 24px;
          font-family: Arial, sans-serif;
          font-size: 1em;
          color: #ddd;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
        }

        .radio-SVG {
          display: flex;
          align-items: center;
          cursor: pointer;
        }

        #preview {
          margin:0 auto;
          max-width: 100%;
          max-height: 100%;
        }

        textarea {
          grid-row: 1 / 2;
          width: 100%;
          height: 200px;
          background-color: #222;
          border: 1px solid #333;
          color: #ddd;
        }

        input#imid {
          flex-grow: 1;
          padding-top: 5px;
          padding-bottom: 5px;
          background-color: #222;
          border: 1px solid #333;
          padding-inline: 5px;
          max-width: 225px;
          border-radius: 7px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .hide {
            display: none;
        }

        .svg-icon {
          vertical-align: middle;
        }

        #image-container {
          display: grid;
          grid-template-rows: 1fr 1fr;
        }

        #button-container {
          display: flex;
          padding-bottom: 10px;
          padding-top: 10px;
        }

        .buttonclass {
          flex: 1;
          padding-top: 5px;
          padding-bottom: 5px;
        }

        .gap {
          width: 10px;
        }

        #submitConvert::before {
          content: "";
          display: inline-block;
          background-image: url('data:image/svg+xml;utf8, <svg style="width:24px;height:24px" viewBox="0 0 24 24" <path fill="currentColor" d="M12,6V9L16,5L12,1V4A8,8 0 0,0 4,12C4,13.57 4.46,15.03 5.24,16.26L6.7,14.8C6.25,13.97 6,13 6,12A6,6 0 0,1 12,6M18.76,7.74L17.3,9.2C17.74,10.04 18,11 18,12A6,6 0 0,1 12,18V15L8,19L12,23V20A8,8 0 0,0 20,12C20,10.43 19.54,8.97 18.76,7.74Z" /></svg>');
          width: 36px;
          height: 36px;
        }

        a:link {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }

        a:visited {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }

        a:hover {
          color: #ddd;
          background-color: transparent;
          text-decoration: none;
        }

        a:active {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }

        .not-used,
        .adv-ui-hide {
          display:none !important
        }

        .adv-ui-show {
          display:
        }
    </style>
    <script type="text/javascript">
      let d = document;
      function gId(e) {return d.getElementById(e);}
      function cE(e) {return d.createElement(e);}
    </script>
  </head>
  <body>
    <a id="return_main_menu" href="index.htm">
      <svg height="24px" width="24px" viewBox="0 0 16 16" id="Layer_1">
        <path fill="white" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"/>
      </svg>
    </a>
    <h3>Image Converter</h3>
    <details>
      <summary>Instructions</summary> For best results, use an image that matches the dimensions of the LED matrix, or if relying on autoscaling use an image with dimensions that are an integer multiple of the matrix's dimensions. <br> Source images with an alpha channel are supported. If an image with transparency is used on the Combine Effects page the layer below it will visible. <br> Proxy Color is replaced by the dynamic color, or the color selected for the image on the Combine Effects page. Anti-fingerprinting measures for the canvas prevent the colors saved in the JSON file from exactly matching the colors in the source image, so colors that close to the Proxy Color will also be replaced.
    </details>

    <div class="top-part">
      <table id="fieldTable" style="width:100%;table-layout:fixed;align-content:center">
        <tr>
          <td style="vertical-align:middle">
            <label for="curlUrl">Device IP/host name:</label>
          </td>
          <td class="adaptiveTD">
            <input class="fullTextField" type="text" id="curlUrl" autocomplete="on" required value>
          </td>
        </tr>
        <tr>
          <td style="vertical-align:middle">
            <div id="showHideAdvDiv" class="radio-SVG" onclick="showHideAdv()">
              <svg id="showHideAdvDivSVG" style="width:36px;height:36px" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z" />
              </svg> &nbsp;Show/Hide Advanced Options
            </div>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
            <label for="proxyColor">Proxy Color:</label>
          </td>
          <td class="adaptiveTD">
            <input class="fullTextField" type="text" id="proxyColor" onfocusout="(function(e){e.reportValidity()})(this);if(this.checkValidity()){gen();}" autocomplete="off" pattern="^(?:[0-9a-fA-F]{3}){1,2}$" placeholder="RGB code (e.g. 4682B4) or leave blank" title="RGB color code (e.g. 4682B4) or leave blank" value>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
            <label for="ledSetupSelector">LED Matrix Type: </label>
          </td>
          <td class="adaptiveTD">
            <select id="ledSetupSelector" class="mainSelector">
              <option value="matrix">2D Matrix </option>
              <option value="r2l" selected="selected">Serpentine, first row right to left &lt;-</option>
              <option value="l2r">Serpentine, first row left to right -&gt;</option>
            </select>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
          </td>
          <td style="vertical-align:middle">
            <div id="setStretchOptionDiv" class="radio-SVG" onclick="setStretchOption()">
              <svg id="setStretchOptionDivSVG" style="width:36px;height:36px" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z" />
              </svg> &nbsp;Stretch Image To Fit
            </div>
          </td>
        </tr>
        <tr class="not-used">
          <td style="vertical-align:middle">
            <label for="brightnessNumber">Brightness: </label>
          </td>
          <td style="vertical-align:middle;display:flex;align-items:center">
            <input type="range" id="brightnessNumber" min="1" max="255" value="128">
            <span id="brightnessValue">128</span>
          </td>
        </tr>
      </table>
      </p>
      <p>
        <label for="file-picker">
          <div id="drop-zone"> Click to select a file </div>
        </label>
      </p>
      <p>
        <input type="file" id="file-picker" style="display:none">
      </p>
      <div style="width:100%;text-align:center">
        <img id="preview" style="display:none" src="data:text/html;base64,">
      </div>
      <div id="raw-image-container" style="display:none">
        <img id="image" src="data:text/html;base64," alt="RawImage image">
      </div>
      <p></p>
      <div id="image-container" style="display:none">
        <div id="image-info" style="display:none"></div>
        <textarea id="JSONled" readonly="readonly" class="adv-ui-hide"></textarea>
      </div>
      <div id="button-container" style="display:none">
        <input type="text" id="imid" maxlength="26" required>
        <div id="gap1" class="gap"></div>
        <button id="sendJSONledbutton" class="buttonclass"></button>
      </div>
    </div>
    <div id="bottom-part" style="display:none" class="bottom-part"></div>
    <canvas id="pixelCanvas"></canvas>


    <script src="js/template_variables.js"></script>
    <!--static.js-->
    <script>
      //elements
      let gurl = gId('curlUrl');
      let prw = gId("preview");
      let JLD = gId('JSONled');
      let brgh = gId("brightnessNumber");
      let lSS  = gId("ledSetupSelector");
      let imin = gId('image-info');
      let imcn = gId('image-container');
      let bcn = gId("button-container");
      let im = gId('image');
      let ss = gId("saveSvg");
      let w = window;
      let canvas = gId('pixelCanvas');
      let brgV = gId("brightnessValue");
      let shaDiv = gId("showHideAdvDiv");
      let ssoDiv = gId("setStretchOptionDiv");
      let pxcolor = gId("proxyColor");
      let imid = gId("imid");

      let fileJSON = '';

      let hideableRows = d.querySelectorAll(".ha-hide");
      for (let i = 0; i < hideableRows.length; i++) {
        hideableRows[i].classList.add("hide");
      }

      let accentColor = '#eee';
      let accentTextColor = '#777';
      let prsCol = '#ccc';
      let greenColor = '#056b0a';
      let redColor = '#6b050c';

      let toggleOffd = "M17,7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7M7,15A3,3 0 0,1 4,12A3,3 0 0,1 7,9A3,3 0 0,1 10,12A3,3 0 0,1 7,15Z";
      let toggleOnd = "M17,7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7M17,15A3,3 0 0,1 14,12A3,3 0 0,1 17,9A3,3 0 0,1 20,12A3,3 0 0,1 17,15Z";
    </script>

    <!--getPixelValues.js-->
    <script>

      function getPixelRGBValues(base64Image) {
        let segID = 0;
        let selectedIndex = lSS.selectedIndex;
        const ledSetupSelection = lSS.options[selectedIndex].value;

        const colorSeparatorStart = '"';
        const colorSeparatorEnd = '"';

        let imageInfo = '';

        // Create an image element and set its src to the base64 image
        let image = new Image();
        image.src = base64Image;

        // Wait for the image to load before drawing it onto the canvas
        image.onload = function() {
          // LED matrix dimensions
          if (t_num_rows.replaceAll("~", "") === "NUM_ROWS") {
            t_num_rows = "16";
          }
          if (t_num_cols.replaceAll("~", "") === "NUM_COLS") {
            t_num_cols = "16";

          }
          const sizeY = parseInt(t_num_rows);
          const sizeX = parseInt(t_num_cols);
          const canvasAspectRatio = sizeX / sizeY;
          const imageAspectRatio = this.naturalWidth / this.naturalHeight;


          const ssoPath = ssoDiv.children[0].children[0];
          const ssoColor = ssoPath.getAttribute("fill");

          imageInfo = '<p>Output Image Width: ' + sizeX + ', Height: ' + sizeY + '</p>'

          const canvas_test = document.createElement('canvas');
          const gl_test = canvas_test.getContext('webgl2');

          let pixelData;
          if (gl_test) {
            //using getImageData from the pixel data from a canvas has a couple of problems.
            // 1) anti-fingerprinting ("farbling") in firefox will add a tiny amount of noise to some pixels.
            //    this can cause values near 0 or 255 to underflow or overflow completely changing
            //    the color. anti-fingerprinting is not used if the page is viewed using file://
            // 2) pixels are premultiplied by alpha which can lead to rounding issues making a
            //    pixel value slightly different from the original image.
            //    these slight differences make it harder to set the Proxy Color, because the
            //    color found using the eye dropper in the image editor might not match the
            //    color output from the canvas.
            // using webgl and readPixels instead of getImageData is a work around for these problems.

            const canvas = document.createElement('canvas');
            canvas.width = sizeX;
            canvas.height = sizeY;
            const gl = canvas.getContext('webgl2');

            // --- Setup Shader Sources ---
            const vsSource = `#version 300 es
            in vec2 a_position;
            in vec2 a_texCoord;
            out vec2 v_texCoord;
            uniform vec2 u_scale;
            void main() {
                vec2 scaled = a_position * u_scale;
                gl_Position = vec4(scaled, 0, 1);
                v_texCoord = a_texCoord;
            }
            `;

            const fsSource = `#version 300 es
            precision mediump float;
            in vec2 v_texCoord;
            out vec4 outColor;
            uniform sampler2D u_image;
            void main() {
                outColor = texture(u_image, v_texCoord);
            }
            `;

            // --- Compile Shader Program ---
            function createShader(gl, type, src) {
              const shader = gl.createShader(type);
              gl.shaderSource(shader, src);
              gl.compileShader(shader);
              return shader;
            }

            function createProgram(gl, vsSrc, fsSrc) {
              const vShader = createShader(gl, gl.VERTEX_SHADER, vsSrc);
              const fShader = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
              const program = gl.createProgram();
              gl.attachShader(program, vShader);
              gl.attachShader(program, fShader);
              gl.linkProgram(program);
              return program;
            }

            const program = createProgram(gl, vsSource, fsSource);
            gl.useProgram(program);

            // --- Create a quad covering NDC space ---
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
              -1, -1,   1, -1,
              -1,  1,   1,  1,
            ]), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
              0, 0, 1, 0,
              0, 1, 1, 1,
            ]), gl.STATIC_DRAW);

            // --- Set up VAO ---
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            const posLoc = gl.getAttribLocation(program, "a_position");
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const texLoc = gl.getAttribLocation(program, "a_texCoord");
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

            // --- Load image into texture ---
            const imageTex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, imageTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // --- Create framebuffer and render target texture ---
            const targetTex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, targetTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX, sizeY, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTex, 0);

            // --- Calculate uniform scale based on aspect ratio ---
            let scaleX = 1, scaleY = 1;
            //if (ssoColor !== accentColor) || imageAspectRatio !== canvasAspectRatio) {
            if (ssoColor !== accentColor) {
              // no stretch, preserve aspect ratio
              if (imageAspectRatio > canvasAspectRatio) {
                // letterbox
                scaleY = canvasAspectRatio / imageAspectRatio;
              }
              else {
                // pillarbox
                scaleX = imageAspectRatio / canvasAspectRatio;
              }
            }

            gl.viewport(0, 0, sizeX, sizeY);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            gl.uniform2f(gl.getUniformLocation(program, "u_scale"), scaleX, scaleY);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, imageTex);
            gl.uniform1i(gl.getUniformLocation(program, "u_image"), 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // --- Read scaled pixels ---
            pixelData = new Uint8Array(sizeX * sizeY * 4);
            gl.readPixels(0, 0, sizeX, sizeY, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
          }
          else {
            // webgl is not available so fallback to using canvas
            const canvas = document.createElement('canvas');
            canvas.width = sizeX;
            canvas.height = sizeY;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            //ctx.imageSmoothingEnabled = false; // should give a pixelated look, but does not look great
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";

            //if (ssoColor !== accentColor) || imageAspectRatio !== canvasAspectRatio) {
            if (ssoColor !== accentColor) {
              // no stretch, preserve aspect ratio
              console.log('no stretch')
              let scaledWidth, scaledHeight;
              if (imageAspectRatio > 1) {
                // letterbox
                scaledWidth = canvas.width;
                scaledHeight = canvas.width / imageAspectRatio;
              }
              else {
                // pillarbox
                scaledWidth = canvas.height * imageAspectRatio;
                scaledHeight = canvas.height;
              }

              // Calculate offsets to center the image
              const xOffset = (canvas.width - scaledWidth) / 2;
              const yOffset = (canvas.height - scaledHeight) / 2;

              ctx.fillStyle = "#00000000";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(image, xOffset, yOffset, scaledWidth, scaledHeight);
            }
            else {
              // stretch to fit
              // scale image to fit canvas. if image does not have the same aspect ratio it will be stretched to fit.
              ctx.drawImage(this, 0, 0, this.naturalWidth, this.naturalHeight, 0, 0, sizeX, sizeY);
            }

            pixelData = ctx.getImageData(0, 0, sizeX, sizeY).data;
          }

          // Create an array to hold the RGB values of each pixel
          let pixelRGBValues = [];

          // If the first row of the led matrix is right -> left
          let right2leftAdjust = 1;
          if (ledSetupSelection == 'l2r') {
            right2leftAdjust = 0;
          }


          // Loop through the pixel data and get the RGB values of each pixel
          for (let i = 0; i < pixelData.length; i += 4) {
            let r = pixelData[i];
            let g = pixelData[i + 1];
            let b = pixelData[i + 2];
            let a = pixelData[i + 3];

            let pixel = i/4
            let row = Math.floor(pixel/sizeX);
            let led = pixel;
            if (ledSetupSelection == 'matrix') {
              //Do nothing, the matrix is set upp like the index in the image
              //Every row starts from the left, i.e. no zigzagging
            }
            else if ((row + right2leftAdjust) % 2 === 0) {
              //Setup is traditional zigzag
              //right2leftAdjust basically flips the row order if = 1
              //Row is left to right
              //Leave led index as pixel index

            }
            else {
              //Setup is traditional zigzag
              //Row is right to left
              //Invert index of row for led
              let indexOnRow = led - (row * sizeX);
              let maxIndexOnRow = sizeX - 1;
              let reversedIndexOnRow = maxIndexOnRow - indexOnRow;
              led = (row * sizeX) + reversedIndexOnRow;
            }

            // Add the RGB values to the pixel RGB values array
            pixelRGBValues.push([r, g, b, a, led, pixel, row]);
          }

          pixelRGBValues.sort((a, b) => a[5] - b[5]);

          //Copy the values to a new array for resorting
          let ledRGBValues = [... pixelRGBValues];

          //Sort the array based on led index
          ledRGBValues.sort((a, b) => a[4] - b[4]);

          //Generate JSON in WLED format
          let JSONledString = '';

          //Set starting values for the segment check to something that is no color
          let segmentStart = -1;
          let maxi = ledRGBValues.length;
          let commandArray = [];

          //For every pixel in the LED array
          for (let i = 0; i < maxi; i++) {
            let pixel = ledRGBValues[i];
            let r = pixel[0];
            let g = pixel[1];
            let b = pixel[2];
            let a = pixel[3];
            let segmentString = '';
            let segmentEnd = -1;

            if (segmentStart < 0) {
              //This is the first led of a new segment
              segmentStart = i;
            } //Else we already have a start index

            if (i < maxi - 1) {

              let iNext = i + 1;
              let nextPixel = ledRGBValues[iNext];

              if (nextPixel[0] != r || nextPixel[1] != g || nextPixel[2] != b || nextPixel[3] != a) {
                //Next pixel has new color
                //The current segment ends with this pixel
                segmentEnd = i + 1 //WLED wants the NEXT LED as the stop led...
                if (segmentStart == i) {
                  //If only one led/pixel, no segment info needed
                  if (JSONledString == '') {
                    //If addressing is single, we need to start every command with a starting possition
                    segmentString = '' + i + ',';
                    //Fixed to b2
                  }
                  else{
                    segmentString = '';
                  }
                }
                else {
                  segmentString = segmentStart + ',' + segmentEnd + ',';
                }
              }

            }
            else {
              //This is the last pixel, so the segment must end
              segmentEnd = i + 1;

              if (segmentStart + 1 == segmentEnd) {
                //If only one led/pixel, no segment info needed
                if (JSONledString == '') {
                  //If addressing is single, we need to start every command with a starting position
                  segmentString = '' + i + ',';
                  //Fixed to b2
                }
                else {
                  segmentString = '';
                }
              }
              else {
                segmentString = segmentStart + ',' + segmentEnd + ',';
              }
            }

            if (segmentEnd > -1) {
              //This is the last pixel in the segment, write to the JSONledString
              const [red, green, blue, alpha] = [r, g, b, a];
              let colorValueString = `${[red, green, blue, alpha].map(x => x.toString(16).padStart(2, '0')).join('')}`;

              JSONledString += segmentString + colorSeparatorStart + colorValueString + colorSeparatorEnd;

              if (i == maxi - 1) {
                fileJSON = JSONledString;
                JSONledString = ''; //Start on an new command string
              }
              else {
                //Add a comma to continue the command string
                JSONledString = JSONledString + ',';
              }
              //Reset segment values
              segmentStart = - 1;
            }
          }

          fileJSON = `{"t":"im",${(pxcolor.value && pxcolor.checkValidity())?'"pc":"0x'+pxcolor.value+'",':''}"i":[` + fileJSON + ']}';
          JLD.value = fileJSON;

          let infoDiv = imin;
          let canvasDiv = imin;

          infoDiv.innerHTML = imageInfo;
          canvasDiv.style.display = "block"

          //Drawing the image
          drawBoxes(pixelRGBValues, sizeX, sizeY);
        }
      }
    </script>

    <!--boxdraw.js-->
    <script>
      function drawBoxes(inputPixelArray, widthPixels, heightPixels) {
        let w = window;

        // Get the canvas context
        let ctx = canvas.getContext('2d', { willReadFrequently: true });

        // Set the width and height of the canvas
        if (w.innerHeight < w.innerWidth) {
          canvas.width = Math.floor(w.innerHeight * 0.98);
        }
        else {
          canvas.width = Math.floor(w.innerWidth * 0.98);
        }
        //canvas.height = w.innerWidth;

        let pixelSize = Math.floor(canvas.width/widthPixels);

        let xOffset = (w.innerWidth - (widthPixels * pixelSize))/2

        //Set the canvas height to fit the right number of pixelrows
        canvas.height = (pixelSize * heightPixels) + 10

        //Iterate through the matrix
        for (let y = 0; y < heightPixels; y++) {
          for (let x = 0; x < widthPixels; x++) {
            // Calculate the index of the current pixel
            let i = (y*widthPixels) + x;

            //Gets the RGB of the current pixel
            let pixel = inputPixelArray[i];

            let pixelColor = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';

            let textColor = 'rgb(128,128,128)';

            // Set the fill style to the pixel color
            ctx.fillStyle = pixelColor;

            //Draw the rectangle
            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);

            // Draw a border on the box
            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);

            //Write text to box
            ctx.font = "10px Arial";
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = 'middle';
            ctx.fillText((pixel[4]), (x * pixelSize) + (pixelSize /2), (y * pixelSize) + (pixelSize /2));
          }
        }
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = w.innerWidth;
        ctx.putImageData(imageData, xOffset, 0);
      }
    </script>

    <!--pixart.js-->
    <script>
      //Start up code
      let devMode =  false; //Remove

      // autocomplete will fill in value after reload if protocol is file (i.e. running locally)
      // so do not replace if protocol is file
      if (window.location.protocol !== "file:") {
        gurl.value = location.host;
      }

      function gen() {
        //Generate image if enough info is in place
        //Is host non empty
        //Is image loaded
        //is scale > 0
        if (prw.style.display != 'none') {
          //regenerate
          let base64Image = prw.src;
          if (isValidBase64Gif(base64Image)) {
            im.src = base64Image;
            getPixelRGBValues(base64Image);
            imcn.style.display = "block";
            bcn.style.display = "";
          }
          else {
            let imageInfo = '<p><b>WARNING!</b> File does not appear to be a valid image</p>';
            imin.innerHTML = imageInfo;
            imin.style.display = "block";
            imcn.style.display = "none";
            JLD.value = '';
            if (devMode) console.log("The string '" + base64Image + "' is not a valid base64 image.");
          }
        }
      }

      // Event listeners =======================

      lSS.addEventListener("change", gen);
      brgh.addEventListener("change", gen);
      gurl.addEventListener("change", gen);
      prw.addEventListener("load", gen);

      gId("sendJSONledbutton").addEventListener('click', async () => {
        if (gurl.reportValidity() && imid.reportValidity()) {
          postPixels();
        }
      });

      brgh.oninput = () => {
        brgV.textContent = brgh.value;
        let perc = parseInt(brgh.value)*100/255;
        let val = `linear-gradient(90deg, #bbb ${perc}%, #333 ${perc}%)`;
        brgh.style.backgroundImage = val;
      }

      async function postPixels() {
        let success = false;
        let ss = gId("saveSvg");
        ss.setAttribute("fill", prsCol);
        let el_btn_save_text = document.getElementById('btn_save_text');
        el_btn_save_text.innerText = "Saving";
        try {
          if (devMode) console.log(i);
          if (devMode) console.log(i.length);
          const response = await fetch('http://'+gurl.value+'/save', {
            method: "POST",
            headers: {
              "Content-Type":"application/x-www-form-urlencoded"
            },
            body:`t=im&id=${encodeURIComponent(imid.value)}&json=`+fileJSON
          });
          if (!response.ok) {
            throw new Error(`Error saving ${imid.value}`);
          }
          const data = await response.json();
          if (devMode) console.log(data);
          success = true;
        }
        catch (error) {
          console.error(error);
        }

        if (success) {
          ss.setAttribute("fill", "#056b0a");
          el_btn_save_text.innerText = "Saved";
          setTimeout(function(){el_btn_save_text.innerText = "Save";}, 1000);
        }
        else {
          ss.setAttribute("fill", "#6b050c");
          el_btn_save_text.innerText = "Error";
        }
      }

      //File uploader code
      const dropZone = gId('drop-zone');
      const filePicker = gId('file-picker');
      const preview = prw;

      // Listen for dragenter, dragover, and drop events
      // Drag and drop causes buggy behavior
      //dropZone.addEventListener('dragenter', dragEnter);
      //dropZone.addEventListener('dragover', dragOver);
     // dropZone.addEventListener('drop', dropped);
      dropZone.addEventListener('click', zoneClicked);

      // Listen for change event on file picker
      filePicker.addEventListener('change', filePicked);

      // Handle zone click
      function zoneClicked(e) {
        e.preventDefault();
        //this.classList.add('drag-over');
        //alert('Hej');
        filePicker.click();
      }

      // Handle dragenter
      function dragEnter(e) {
        e.preventDefault();
        this.classList.add('drag-over');
      }

      // Handle dragover
      function dragOver(e) {
        e.preventDefault();
      }

      // Handle drop
      function dropped(e) {
        e.preventDefault();
        this.classList.remove('drag-over');

        // Get the dropped file
        const file = e.dataTransfer.files[0];
        updatePreview(file)
      }

      // Handle file picked
      function filePicked(e) {
        // Get the picked file
        const file = e.target.files[0];
        updatePreview(file)
      }

      // Update the preview image
      function updatePreview(file) {
        imid.value = file.name.replace(/\.[^/.]+$/, "").substr(0, 26);
        // Use FileReader to read the file
        const reader = new FileReader();
        reader.onload = () => {
          // Update the preview image
          preview.src = reader.result;
          //gId("submitConvertDiv").style.display = "";
          prw.style.display = "";
        };
        reader.readAsDataURL(file);
      }

      function isValidBase64Gif(string) {
        // Use a regular expression to check that the string is a valid base64 string
        /*
        const base64gifPattern = /^data:image\/gif;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64pngPattern = /^data:image\/png;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64jpgPattern = /^data:image\/jpg;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64webpPattern = /^data:image\/webp;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        */
        //REMOVED, Any image appear to work as long as it can be drawn to the canvas. Leaving code in for future use, possibly
        if (1==1 || base64gifPattern.test(string) || base64pngPattern.test(string) || base64jpgPattern.test(string) || base64webpPattern.test(string)) {
          return true;
        }
        else {
          //Not OK
          return false;
        }
      }

      hideableRows = d.querySelectorAll(".ha-hide");
      for (let i = 0; i < hideableRows.length; i++) {
        hideableRows[i].classList.add("hide");
      }


      function showHideAdv() {
        let e = shaDiv.children[0].children[0];
        let color = e.getAttribute("fill");
        let d = '';
        if (color === accentColor) {
          color = accentTextColor;
          d = toggleOffd;
        }
        else {
          color = accentColor;
          d = toggleOnd;
        }
        e.setAttribute("fill", color);
        e.setAttribute("d", d);
        let adve = document.querySelectorAll("[class^=adv-ui]");
        for (let i = 0; i < adve.length; i++) {
          adve[i].classList.toggle("adv-ui-hide");
          adve[i].classList.toggle("adv-ui-show");
        }
        gen();
      }

      function setStretchOption() {
        let e = ssoDiv.children[0].children[0];
        let color = e.getAttribute("fill");
        let d = '';
        if (color === accentColor) {
          color = accentTextColor;
          d = toggleOffd;
        }
        else {
          color = accentColor;
          d = toggleOnd;
        }
        e.setAttribute("fill", color);
        e.setAttribute("d", d);
        gen();
      }

      //gId("sendJSONledbutton").innerHTML = 
      //'<svg class="svg-icon" style="width:36px;height:36px" viewBox="0 -960 960 960"> <path id="saveSvg" fill="currentColor" d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg>&nbsp; Save</button>'
      gId("sendJSONledbutton").innerHTML = 
      '<svg class="svg-icon" style="width:36px;height:36px" viewBox="0 -960 960 960"> <path id="saveSvg" fill="currentColor" d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg> &nbsp; <span id="btn_save_text">Save</span>'

      // set default value of "Stretch Image To Fit" to on
      window.addEventListener("load", setStretchOption);
    </script>
  </body>
</html>
