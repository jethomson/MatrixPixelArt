<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Image Converter</title>
    <style>
        .box {
          border: 2px solid #fff;
        }
        
        body {
          font-family: Arial, sans-serif;
          color: #faffff;
          background: #111;
          font-size: 17px;
          text-align: center;
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: transparent;
        }

        #return_main_menu {
          float: left;
        }

        .top-part {
          width: 600px;
          margin: 0 auto;
        }
        .container {
          max-width: 100% -40px;
          border-radius: 0px;
          padding: 20px;
          text-align: center;
        }
        
        p {
          font-size: 1em;
          color: #777;
          line-height: 1.5;
          font-family: Arial, sans-serif;
        }
        
        #fieldTable {
          font-size: 1  em;
          color: #777;
          line-height: 1;
          font-family: Arial, sans-serif;
        }
        
        #scaleTable {
          font-size: 1  em;
          color: #777;
          line-height: 1;
          font-family: Arial, sans-serif;
        }
        
        #drop-zone {
          display: block;
          width: 100%-40px;
          border: 3px dashed #ddd;
          border-radius: 0px;
          text-align: center;
          padding: 20px;
          margin: 0px;
          cursor: pointer;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #777;
        }
        
        #file-picker {
          display: none;
        }
        .adaptiveTD{
          display: flex;
          flex-direction: row;
          flex-wrap: nowrap;
          align-items: center;
        
        }
        
        .mainSelector {
          background-color: #222;
          color: #ddd;
          border: 1px solid #333;
          margin-top: 4px;
          margin-bottom: 4px;
          padding: 0 8px;
          height: 28px;
          font-size: 15px;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .adaptiveSelector {
          background-color: #222;
          color: #ddd;
          border: 1px solid #333;
          margin-top: 4px;
          margin-bottom: 4px;
          padding: 0 8px;
          height: 28px;
          font-size: 15px;
          border-radius: 7px;
          flex-grow: 1;
          display: none;
        }
        
        .segmentsDiv{
          width: 36px;
          padding-left: 5px;
        }
        
        * input[type=range] {
          appearance: none;
          -moz-appearance: none;
          -webkit-appearance: none;
          flex-grow: 1;
          padding: 0;
          margin: 4px 8px 4px 0;
          background-color: transparent;
          cursor: pointer;
          background: linear-gradient(to right, #bbb 50%, #333 50%);
          border-radius: 7px;
        }
        
        input[type=range]:focus {
          outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
          height: 28px;
          cursor: pointer;
          background: transparent;
          border-radius: 7px;
        }
        input[type=range]::-webkit-slider-thumb {
          height: 16px;
          width: 16px;
          border-radius: 50%;
          background: #fff;
          cursor: pointer;
          -webkit-appearance: none;
          margin-top: 4px;
          border-radius: 7px;
        }
        input[type=range]::-moz-range-track {
          height: 28px;
          background-color: rgba(0, 0, 0, 0);
          border-radius: 7px;
        }
        input[type=range]::-moz-range-thumb {
          border: 0px solid rgba(0, 0, 0, 0);
          height: 16px;
          width: 16px;
          border-radius: 7px;
          background: #fff;
        }
        
        .rangeNumber{
          width: 20px;
          vertical-align: middle;
        }
        
        .fullTextField[type=text] {
          background-color: #222;
          border: 1px solid #333;
          padding-inline-start: 5px;
          margin-top: 4px;
          margin-bottom: 4px;
          height: 24px;
          border-radius: 0px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .flxTFld{
          background-color: #222;
          border: 1px solid #333;
          padding-inline-start: 5px;
          height: 24px;
          border-radius: 0px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          border-radius: 7px;
          flex-grow: 1;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        * input[type=submit] {
          background-color: #222;
          border: 1px solid #333;
          padding: 0.5em;
          width: 100%;
          border-radius: 24px;
          font-family: Arial, sans-serif;
          font-size: 1.3em;
          color: #ddd;
        }
        
        * button {
          background-color: #222;
          border: 1px solid #333;
          padding-inline: 5px;
          width: 100%;
          border-radius: 24px;
          font-family: Arial, sans-serif;
          font-size: 1em;
          color: #ddd;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
        }

        .radio-SVG {
          display: flex;
          align-items: center;
          cursor: pointer;
        }
        
        #preview {
          margin:0 auto;
          max-width: 100%;
          max-height: 100%;
        }
        
        textarea {
          grid-row: 1 / 2;
          width: 100%;
          height: 200px;
          background-color: #222;
          border: 1px solid #333;
          color: #ddd;
        }
        
        input#imid {
          flex-grow: 1;
          padding-top: 5px;
          padding-bottom: 5px;
          background-color: #222;
          border: 1px solid #333;
          padding-inline: 5px;
          max-width: 225px;
          border-radius: 7px;
          font-family: Arial, sans-serif;
          font-size: 15px;
          color: #ddd;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .hide {
            display: none;
        }
        
        .svg-icon {
          vertical-align: middle;
        }

        #image-container {
          display: grid;
          grid-template-rows: 1fr 1fr;
        }

        #button-container {
          display: flex;
          padding-bottom: 10px;
          padding-top: 10px;
        }
        
        .buttonclass {
          flex: 1;
          padding-top: 5px;
          padding-bottom: 5px;
        }
        
        .gap {
          width: 10px;
        }
        
        #submitConvert::before {
          content: "";
          display: inline-block;
          background-image: url('data:image/svg+xml;utf8, <svg style="width:24px;height:24px" viewBox="0 0 24 24" <path fill="currentColor" d="M12,6V9L16,5L12,1V4A8,8 0 0,0 4,12C4,13.57 4.46,15.03 5.24,16.26L6.7,14.8C6.25,13.97 6,13 6,12A6,6 0 0,1 12,6M18.76,7.74L17.3,9.2C17.74,10.04 18,11 18,12A6,6 0 0,1 12,18V15L8,19L12,23V20A8,8 0 0,0 20,12C20,10.43 19.54,8.97 18.76,7.74Z" /></svg>');
          width: 36px;
          height: 36px;
        }

        a:link {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }
        
        a:visited {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }
        
        a:hover {
          color: #ddd;
          background-color: transparent;
          text-decoration: none;
        }
        
        a:active {
          color: rgba(221, 221, 221, 0.61);
          background-color: transparent;
          text-decoration: none;
        }

        .not-used,
        .adv-ui-hide {
          display:none !important
        }
        
        .adv-ui-show {
          display:
        }
    </style>
    <script type="text/javascript">
      var d = document;
      function gId(e) {return d.getElementById(e);}
      function cE(e) {return d.createElement(e);}
    </script>
  </head>
  <body>
    <a id="return_main_menu" href="index.htm">
      <svg height="24px" width="24px" viewBox="0 0 16 16" id="Layer_1">
        <path fill="white" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"/>
      </svg>
    </a>
    <h3>Image Converter</h3>
    <details>
      <summary>Instructions</summary> For best results, use an image that matches the dimensions of the LED matrix, or if relying on autoscaling use an image with dimensions that are an integer multiple of the matrix's dimensions. <br> Source images with an alpha channel are supported. If an image with transparency is used on the Combine Effects page the layer below it will visible. <br> Proxy Color is replaced by the dynamic color, or the color selected for the image on the Combine Effects page. Anti-fingerprinting measures for the canvas prevent the colors saved in the JSON file from exactly matching the colors in the source image, so colors that close to the Proxy Color will also be replaced.
    </details>
    
    <div class="top-part">
      <table id="fieldTable" style="width:100%;table-layout:fixed;align-content:center">
        <tr>
          <td style="vertical-align:middle">
            <label for="curlUrl">Device IP/host name:</label>
          </td>
          <td class="adaptiveTD">
            <input class="fullTextField" type="text" id="curlUrl" autocomplete="on" required value>
          </td>
        </tr>
        <tr>
          <td style="vertical-align:middle">
            <div id="showHideAdvDiv" class="radio-SVG" onclick="showHideAdv()">
              <svg id="showHideAdvDivSVG" style="width:36px;height:36px" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z" />
              </svg> &nbsp;Show/Hide Advanced Options
            </div>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
            <label for="proxyColor">Proxy Color:</label>
          </td>
          <td class="adaptiveTD">
            <input class="fullTextField" type="text" id="proxyColor" onfocusout="(function(e){e.reportValidity()})(this);if(this.checkValidity()){gen();}" autocomplete="off" pattern="^(?:[0-9a-fA-F]{3}){1,2}$" placeholder="RGB code (e.g. 4682B4) or leave blank" title="RGB color code (e.g. 4682B4) or leave blank" value>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
            <label for="ledSetupSelector">LED Matrix Type: </label>
          </td>
          <td class="adaptiveTD">
            <select id="ledSetupSelector" class="mainSelector">
              <option value="matrix">2D Matrix </option>
              <option value="r2l" selected="selected">Serpentine, first row right to left &lt;-</option>
              <option value="l2r">Serpentine, first row left to right -&gt;</option>
            </select>
          </td>
        </tr>
        <tr class="adv-ui-hide">
          <td style="vertical-align:middle">
          </td>
          <td style="vertical-align:middle">
            <div id="setStretchOptionDiv" class="radio-SVG" onclick="setStretchOption()">
              <svg id="setStretchOptionDivSVG" style="width:36px;height:36px" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z" />
              </svg> &nbsp;Stretch Image To Fit
            </div>
          </td>
        </tr>
        <tr class="not-used">
          <td style="vertical-align:middle">
            <label for="brightnessNumber">Brightness: </label>
          </td>
          <td style="vertical-align:middle;display:flex;align-items:center">
            <input type="range" id="brightnessNumber" min="1" max="255" value="128">
            <span id="brightnessValue">128</span>
          </td>
        </tr>
      </table>
      </p>
      <p>
        <label for="file-picker">
          <div id="drop-zone"> Click to select a file </div>
        </label>
      </p>
      <p>
        <input type="file" id="file-picker" style="display:none">
      </p>
      <div style="width:100%;text-align:center">
        <img id="preview" style="display:none" src="data:text/html;base64,">
      </div>
      <div id="raw-image-container" style="display:none">
        <img id="image" src="data:text/html;base64," alt="RawImage image">
      </div>
      <p></p>
      <div id="image-container" style="display:none">
        <div id="image-info" style="display:none"></div>
        <textarea id="JSONled" readonly="readonly" class="adv-ui-hide"></textarea>
      </div>
      <div id="button-container" style="display:none">
        <input type="text" id="imid" maxlength="26" required>
        <div id="gap1" class="gap"></div>
        <button id="sendJSONledbutton" class="buttonclass"></button>
      </div>
    </div>
    <div id="bottom-part" style="display:none" class="bottom-part"></div>
    <canvas id="pixelCanvas"></canvas>


    <script src="js/template_variables.js"></script>
    <!--static.js-->
    <script> 
      //elements
      var gurl = gId('curlUrl');
      var prw = gId("preview");
      var JLD = gId('JSONled');
      var brgh = gId("brightnessNumber");
      var lSS  = gId("ledSetupSelector");
      var imin = gId('image-info');
      var imcn = gId('image-container');
      var bcn = gId("button-container");
      var im = gId('image');
      var ss = gId("saveSvg");
      var w = window;
      var canvas = gId('pixelCanvas');
      var brgV = gId("brightnessValue");
      var shaDiv = gId("showHideAdvDiv");
      var ssoDiv = gId("setStretchOptionDiv");
      var pxcolor = gId("proxyColor");
      var imid = gId("imid");

      var fileJSON = '';
      
      var hideableRows = d.querySelectorAll(".ha-hide");
      for (var i = 0; i < hideableRows.length; i++) {
        hideableRows[i].classList.add("hide");
      }
      
      var accentColor = '#eee';
      var accentTextColor = '#777';
      var prsCol = '#ccc';
      var greenColor = '#056b0a';
      var redColor = '#6b050c';
      
      var toggleOffd = "M17,7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7M7,15A3,3 0 0,1 4,12A3,3 0 0,1 7,9A3,3 0 0,1 10,12A3,3 0 0,1 7,15Z";
      var toggleOnd = "M17,7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7M17,15A3,3 0 0,1 14,12A3,3 0 0,1 17,9A3,3 0 0,1 20,12A3,3 0 0,1 17,15Z";
    </script>
              
    <!--getPixelValues.js-->
    <script>

      function getPixelRGBValues(base64Image) {
        let segID = 0;
      
        const formatSelection = "wled";
        
        let selectedIndex = lSS.selectedIndex;
        const ledSetupSelection = lSS.options[selectedIndex].value;
      
        let curlString = ''
      
        let colorSeparatorStart = '"';
        let colorSeparatorEnd = '"';

        let imageInfo = '';
        
        // Create two off-screen canvases
        // The image is scaled by drawing to canvas, then canvas is copied into the webgl texture.
        // Using two canvases is much easier than scaling with webgl directly.
        var canvas = cE('canvas');
        var glcanvas = cE('canvas');
        var ctx = canvas.getContext('2d', { willReadFrequently: true });
        var gl = glcanvas.getContext("webgl2");

        //ctx.imageSmoothingEnabled = false; // should give a pixelated look, but does not look great
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
      
        // Create an image element and set its src to the base64 image
        var image = new Image();
        image.src = base64Image;
      
        // Wait for the image to load before drawing it onto the canvas
        image.onload = function() {
          // LED matrix dimensions
          if (t_num_rows.replaceAll("~", "") === "NUM_ROWS") {
            t_num_rows = "16";
          }
          if (t_num_cols.replaceAll("~", "") === "NUM_COLS") {
            t_num_cols = "16";

          }
          let sizeY = parseInt(t_num_rows);
          let sizeX = parseInt(t_num_cols);
          canvas.width = sizeX;
          canvas.height = sizeY;
          
          imageInfo = '<p>Output Image Width: ' + sizeX + ', Height: ' + sizeY + '</p>'

          const canvasAspectRatio = sizeX / sizeY;
          const imageAspectRatio = this.naturalWidth / this.naturalHeight;

          let ssoPath = ssoDiv.children[0].children[0];
          let ssoColor = ssoPath.getAttribute("fill");
          if (ssoColor === accentColor || imageAspectRatio === canvasAspectRatio) {
            // scale image to fit canvas. if image does not have the same aspect ratio it will be stretched to fit.
            ctx.drawImage(this, 0, 0, this.naturalWidth, this.naturalHeight, 0, 0, sizeX, sizeY);
          }
          else {
            let scaledWidth, scaledHeight;
            if (imageAspectRatio > 1) {
                // letterbox
                scaledWidth = canvas.width;
                scaledHeight = canvas.width / imageAspectRatio;
            }
            else {
                // pillarbox
                scaledWidth = canvas.height * imageAspectRatio;
                scaledHeight = canvas.height;
            }

            // Calculate offsets to center the image
            const xOffset = (canvas.width - scaledWidth) / 2;
            const yOffset = (canvas.height - scaledHeight) / 2;

            ctx.fillStyle = "#00000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, xOffset, yOffset, scaledWidth, scaledHeight);
          }

          var pixelData;
          if (gl) {
            // using webgl and readPixels instead of getImageData is a work around for pixel errors caused
            // by canvas anti-fingerprinting and possibly loss of precision caused by premultiplied alpha color values
            // I believe the tiny noise added to pixels by firefox's canvas anti-fingerprinting method causes
            // values near 0 or 255 to underflow or overflow which completely changes the color.
            gl.activeTexture(gl.TEXTURE0);
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ctx.canvas);
            gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
            
            pixelData = new Uint8Array(sizeX * sizeY * 4);
            gl.readPixels(0, 0, sizeX, sizeY, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
          }
          else {
            pixelData = ctx.getImageData(0, 0, sizeX, sizeY).data;
          }
        
          // Create an array to hold the RGB values of each pixel
          var pixelRGBValues = [];
      
          // If the first row of the led matrix is right -> left
          let right2leftAdjust = 1;
          if (ledSetupSelection == 'l2r') {
            right2leftAdjust = 0;
          }

/*
          // sort colors by how frequently they occur, so that less common colors that are a near match to more common colors can be consolidated
          // setting less common colors to their more common near match reduces file size and removes extra colors added by canvas anti-fingerprinting (farbling)
          let color = [];
          let frequency = {};
          for (var i = 0; i < pixelData.length; i += 4) {
            let color = [pixelData[w], pixelData[i + 1], pixelData[i + 2], pixelData[i + 3]];
            //console.log(`[${i/4}] color: ` + pixelData[i] + "," + pixelData[i + 1] + "," + pixelData[i + 2] + "," + pixelData[i + 3]);
            if (frequency[color]) {
              frequency[color] = frequency[color] + 1;
            }
            else {
              frequency[color] = 1;
            }
          }
          let colorsSorted = Object.keys(frequency).sort(function(a, b) {
            return frequency[b] - frequency[a]
          });
          colorsSorted.forEach((key) => {
            console.log(key + " " + frequency[key]);
          })
*/

          // Loop through the pixel data and get the RGB values of each pixel
          for (var i = 0; i < pixelData.length; i += 4) {
            var r = pixelData[i];
            var g = pixelData[i + 1];
            var b = pixelData[i + 2];
            var a = pixelData[i + 3];

/*
            for (color of colorsSorted) {
              let ref_color = color.split(",").map(Number);
              let dist = Math.abs(ref_color[0] - r) + Math.abs(ref_color[1] - g) + Math.abs(ref_color[2] - b) + Math.abs(ref_color[3] - a);
              if (dist == 0) {
                // need to break on an exact match because there could be a less common near match after this
                break;
              }
              // transparency is never farbled, so only consolidate colors of the same transparency
              if (a == ref_color[3] && dist < 7) {
                //console.log("ref_color: " + ref_color[0] + "," + ref_color[1] + "," + ref_color[2] + "," + ref_color[3]);
                //console.log("data color: " + r + "," + g + "," + b + "," + a);
                r = ref_color[0];
                g = ref_color[1];
                b = ref_color[2];
                break;
              }
            }
            // replace colors that are almost black with complete black
            let dist = Math.abs(0 - r) + Math.abs(0 - g) + Math.abs(0 - b);
            if (0 < dist && dist < 7) {
              r = 0;
              g = 0;
              b = 0;
            }
            // replace colors that are almost the proxy color with the proxy color
            if (pxcolor.value && pxcolor.checkValidity()) {
              let pxca = pxcolor.value.match(/[a-f0-9]{2}/gi);
              let dist = Math.abs(pxca[0] - r) + Math.abs(pxca[1] - g) + Math.abs(pxca[2] - b);
              if (0 < dist && dist < 7) {
                //console.log("pxca: " + pxca[0] + "," + pxca[1] + "," + pxca[2] + "," + pxca[3]);
                //console.log("data color: " + r + "," + g + "," + b + "," + a);
                r = pxca[0];
                g = pxca[1];
                b = pxca[2];
              }
            }
*/
            let pixel = i/4
            let row = Math.floor(pixel/sizeX);
            let led = pixel;
            if (ledSetupSelection == 'matrix') {
                //Do nothing, the matrix is set upp like the index in the image
                //Every row starts from the left, i.e. no zigzagging
            }
            else if ((row + right2leftAdjust) % 2 === 0) {
                //Setup is traditional zigzag
                //right2leftAdjust basically flips the row order if = 1
                //Row is left to right
                //Leave led index as pixel index
              
            }
            else {
                //Setup is traditional zigzag
                //Row is right to left
                //Invert index of row for led
                let indexOnRow = led - (row * sizeX);
                let maxIndexOnRow = sizeX - 1;
                let reversedIndexOnRow = maxIndexOnRow - indexOnRow;
                led = (row * sizeX) + reversedIndexOnRow;
            }
      
            // Add the RGB values to the pixel RGB values array
            pixelRGBValues.push([r, g, b, a, led, pixel, row]);
          }
          
          pixelRGBValues.sort((a, b) => a[5] - b[5]);
      
          //Copy the values to a new array for resorting
          let ledRGBValues = [... pixelRGBValues];
          
          //Sort the array based on led index
          ledRGBValues.sort((a, b) => a[4] - b[4]);
          
          //Generate JSON in WLED format
          let JSONledString = '';
      
          //Set starting values for the segment check to something that is no color
          let segmentStart = -1;
          let maxi = ledRGBValues.length;
          let commandArray = [];
      
          //For every pixel in the LED array
          for (let i = 0; i < maxi; i++) {
            let pixel = ledRGBValues[i];
            let r = pixel[0];
            let g = pixel[1];
            let b = pixel[2];
            let a = pixel[3];
            let segmentString = '';
            let segmentEnd = -1;
      
            if (segmentStart < 0) {
              //This is the first led of a new segment
              segmentStart = i;
            } //Else we already have a start index
            
            if (i < maxi - 1) { 
              
              let iNext = i + 1;
              let nextPixel = ledRGBValues[iNext];
      
              if (nextPixel[0] != r || nextPixel[1] != g || nextPixel[2] != b || nextPixel[3] != a) {
                //Next pixel has new color
                //The current segment ends with this pixel
                segmentEnd = i + 1 //WLED wants the NEXT LED as the stop led...
                if (segmentStart == i) {
                  //If only one led/pixel, no segment info needed
                  if (JSONledString == '') {
                    //If addressing is single, we need to start every command with a starting possition
                    segmentString = '' + i + ',';
                    //Fixed to b2
                  }
                  else{
                    segmentString = '';
                  }
                }
                else {
                  segmentString = segmentStart + ',' + segmentEnd + ',';
                }
              }
      
            }
            else {
              //This is the last pixel, so the segment must end
              segmentEnd = i + 1;
      
              if (segmentStart + 1 == segmentEnd) {
                //If only one led/pixel, no segment info needed
                if (JSONledString == '') {
                  //If addressing is single, we need to start every command with a starting position
                  segmentString = '' + i + ',';
                  //Fixed to b2
                }
                else {
                  segmentString = '';
                }
              }
              else {
                segmentString = segmentStart + ',' + segmentEnd + ','; 
              }
            }
    
            if (segmentEnd > -1) {
              //This is the last pixel in the segment, write to the JSONledString
              const [red, green, blue, alpha] = [r, g, b, a];
              let colorValueString = `${[red, green, blue, alpha].map(x => x.toString(16).padStart(2, '0')).join('')}`;
     
              JSONledString += segmentString + colorSeparatorStart + colorValueString + colorSeparatorEnd;
     
              if (i == maxi - 1) { 
                fileJSON = JSONledString;
                JSONledString = ''; //Start on an new command string
              }
              else {
                //Add a comma to continue the command string
                JSONledString = JSONledString + ',';
              }
              //Reset segment values
              segmentStart = - 1;
            }
          }

          fileJSON = `{"t":"im",${(pxcolor.value && pxcolor.checkValidity())?'"pc":"0x'+pxcolor.value+'",':''}"i":[` + fileJSON + ']}';
          JLD.value = fileJSON;
      
          let infoDiv = imin;
          let canvasDiv = imin;
          
          infoDiv.innerHTML = imageInfo;
          canvasDiv.style.display = "block"
      
          //Drawing the image
          drawBoxes(pixelRGBValues, sizeX, sizeY);
        }
      }
    </script>
      
    <!--boxdraw.js-->
    <script>
      function drawBoxes(inputPixelArray, widthPixels, heightPixels) {
       
          var w = window;
      
          // Get the canvas context
          var ctx = canvas.getContext('2d', { willReadFrequently: true });
      
          // Set the width and height of the canvas
          if (w.innerHeight < w.innerWidth) {
              canvas.width = Math.floor(w.innerHeight * 0.98);
          }
          else {
              canvas.width = Math.floor(w.innerWidth * 0.98);
          }
          //canvas.height = w.innerWidth;
      
          let pixelSize = Math.floor(canvas.width/widthPixels);
      
          let xOffset = (w.innerWidth - (widthPixels * pixelSize))/2
      
          //Set the canvas height to fit the right number of pixelrows
          canvas.height = (pixelSize * heightPixels) + 10
          
          //Iterate through the matrix
          for (let y = 0; y < heightPixels; y++) {
              for (let x = 0; x < widthPixels; x++) {
      
                  // Calculate the index of the current pixel
                  let i = (y*widthPixels) + x;
                  
                  //Gets the RGB of the current pixel
                  let pixel = inputPixelArray[i];
      
                  let pixelColor = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
      
                  let textColor = 'rgb(128,128,128)';
      
                  // Set the fill style to the pixel color
                  ctx.fillStyle = pixelColor;
      
                  //Draw the rectangle
                  ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      
                  // Draw a border on the box
                  ctx.strokeStyle = '#888888';
                  ctx.lineWidth = 1;
                  ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      
                  //Write text to box
                  ctx.font = "10px Arial";
                  ctx.fillStyle = textColor;
                  ctx.textAlign = "center";
                  ctx.textBaseline = 'middle';
                  ctx.fillText((pixel[4]), (x * pixelSize) + (pixelSize /2), (y * pixelSize) + (pixelSize /2));
              }
          }
          var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          canvas.width = w.innerWidth;
          ctx.putImageData(imageData, xOffset, 0);
      }
    </script>
      
    <!--pixart.js-->
    <script>
      //Start up code
      let devMode =  false; //Remove

      // autocomplete will fill in value after reload if protocol is file (i.e. running locally)
      // so do not replace if protocol is file
      if (window.location.protocol !== "file:") {
        gurl.value = location.host;
      }
      
      function gen() {
        //Generate image if enough info is in place
        //Is host non empty
        //Is image loaded
        //is scale > 0
        if (prw.style.display != 'none') {
          //regenerate
          let base64Image = prw.src;
          if (isValidBase64Gif(base64Image)) {
            im.src = base64Image;
            getPixelRGBValues(base64Image);
            imcn.style.display = "block";
            bcn.style.display = "";
          }
          else {
            let imageInfo = '<p><b>WARNING!</b> File does not appear to be a valid image</p>';
            imin.innerHTML = imageInfo;
            imin.style.display = "block";
            imcn.style.display = "none";
            JLD.value = '';
            if (devMode) console.log("The string '" + base64Image + "' is not a valid base64 image.");
          }
        }
      }
      
      // Event listeners =======================
      
      lSS.addEventListener("change", gen);
      brgh.addEventListener("change", gen);
      gurl.addEventListener("change", gen);
      prw.addEventListener("load", gen);
      
      gId("sendJSONledbutton").addEventListener('click', async () => {
        if (gurl.reportValidity() && imid.reportValidity()) {
          postPixels();
        }
      });
      
      brgh.oninput = () => {
        brgV.textContent = brgh.value;
        let perc = parseInt(brgh.value)*100/255;
        var val = `linear-gradient(90deg, #bbb ${perc}%, #333 ${perc}%)`;
        brgh.style.backgroundImage = val;
      }
      
      async function postPixels() {
        let ss = gId("saveSvg");
        ss.setAttribute("fill", prsCol);
        let er = false;
        try {
          if (devMode) console.log(i);
          if (devMode) console.log(i.length);
          const response = await fetch('http://'+gurl.value+'/save', {
            method: "POST",
            headers: {
              "Content-Type":"application/x-www-form-urlencoded"
            },
            body:`t=im&id=${encodeURIComponent(imid.value)}&json=`+fileJSON
          });
          const data = await response.json();
          if (devMode) console.log(data);
        }
        catch (error) {
          console.error(error);
          er = true;
        }
        if (er) {
          //Something went wrong
          ss.setAttribute("fill", redColor);
          setTimeout(function() { 
            ss.setAttribute("fill", accentTextColor);
          }, 1000);
        }
        else {
          // A, OK
          ss.setAttribute("fill", greenColor);
          setTimeout(function() { 
            ss.setAttribute("fill", accentColor);
          }, 1000);
        }
      }
      
      //File uploader code
      const dropZone = gId('drop-zone');
      const filePicker = gId('file-picker');
      const preview = prw;
      
      // Listen for dragenter, dragover, and drop events
      // Drag and drop causes buggy behavior
      //dropZone.addEventListener('dragenter', dragEnter);
      //dropZone.addEventListener('dragover', dragOver);
     // dropZone.addEventListener('drop', dropped);
      dropZone.addEventListener('click', zoneClicked);
      
      // Listen for change event on file picker
      filePicker.addEventListener('change', filePicked);
      
      // Handle zone click
      function zoneClicked(e) {
        e.preventDefault();
        //this.classList.add('drag-over');
        //alert('Hej');
        filePicker.click();
      }
      
      // Handle dragenter
      function dragEnter(e) {
        e.preventDefault();
        this.classList.add('drag-over');
      }
      
      // Handle dragover
      function dragOver(e) {
        e.preventDefault();
      }
      
      // Handle drop
      function dropped(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
      
        // Get the dropped file
        const file = e.dataTransfer.files[0];
        updatePreview(file)
      }
      
      // Handle file picked
      function filePicked(e) {
        // Get the picked file
        const file = e.target.files[0];
        updatePreview(file)
      }
      
      // Update the preview image
      function updatePreview(file) {
        imid.value = file.name.replace(/\.[^/.]+$/, "").substr(0, 26);
        // Use FileReader to read the file
        const reader = new FileReader();
        reader.onload = () => {
          // Update the preview image
          preview.src = reader.result;
          //gId("submitConvertDiv").style.display = "";
          prw.style.display = "";
        };
        reader.readAsDataURL(file);
      }
      
      function isValidBase64Gif(string) {
        // Use a regular expression to check that the string is a valid base64 string
        /*
        const base64gifPattern = /^data:image\/gif;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64pngPattern = /^data:image\/png;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64jpgPattern = /^data:image\/jpg;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        const base64webpPattern = /^data:image\/webp;base64,([A-Za-z0-9+/:]{4})*([A-Za-z0-9+/:]{3}=|[A-Za-z0-9+/:]{2}==)?$/;
        */
        //REMOVED, Any image appear to work as long as it can be drawn to the canvas. Leaving code in for future use, possibly
        if (1==1 || base64gifPattern.test(string) || base64pngPattern.test(string) || base64jpgPattern.test(string) || base64webpPattern.test(string)) {
          return true;
        }
        else {
          //Not OK
          return false;
        }
      }
      
      var hideableRows = d.querySelectorAll(".ha-hide");
      for (var i = 0; i < hideableRows.length; i++) {
        hideableRows[i].classList.add("hide");
      }


      function showHideAdv() {
        let e = shaDiv.children[0].children[0];
        let color = e.getAttribute("fill");
        let d = '';
        if (color === accentColor) {
          color = accentTextColor;
          d = toggleOffd;
        }
        else {
          color = accentColor;
          d = toggleOnd;
        }
        e.setAttribute("fill", color);
        e.setAttribute("d", d);
        let adve = document.querySelectorAll("[class^=adv-ui]");
        for (let i = 0; i < adve.length; i++) {
          adve[i].classList.toggle("adv-ui-hide");
          adve[i].classList.toggle("adv-ui-show");
        }
        gen();
      }

      function setStretchOption() {
        let e = ssoDiv.children[0].children[0];
        let color = e.getAttribute("fill");
        let d = '';
        if (color === accentColor) {
          color = accentTextColor;
          d = toggleOffd;
        }
        else {
          color = accentColor;
          d = toggleOnd;
        }
        e.setAttribute("fill", color);
        e.setAttribute("d", d);
        gen();
      }

      gId("sendJSONledbutton").innerHTML = 
      '<svg class="svg-icon" style="width:36px;height:36px" viewBox="0 -960 960 960"> <path id="saveSvg" fill="currentColor" d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg>&nbsp; Save</button>'
      
      // set default value of "Stretch Image To Fit" to on 
      window.addEventListener("load", setStretchOption); 
    </script>
  </body>
</html>
