<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <meta http-equiv="Cache-Control" content="private, no-store" />
  <title>File Manager</title>
  <style>
  html {
    touch-action: manipulation;
    overflow: auto;
  }

  body {
    font-family: Arial, sans-serif;
    color: #faffff;
    background: #111;
    font-size: 17px;
    text-align: center;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }
  
  a:link {
    color: #1E90FF;
  }

  a:visited {
    color: #9370DB;
  }

  #return_main_menu {
    float: left;
  }

  .grid-container {
    display: grid;
    width: 95vw;
    max-width: 600px;
    max-height: 800px;
    align-items: center;
    margin: 0 auto;
  }
  .grid-checkbox-row {
    text-align: left;
    width: 100%;
    display: block;
    white-space: nowrap;
    padding-left: 1em;
  }
  .grid-item-button {
    font-weight: bold;
    text-align: center;
    width: 100%;
    align-items: center;
  }
  .grid-item:active {
    background: #0e70a4;
  }
  .span-regular-file {
    padding-left: 1em;
  }

  button {
    border: 0;
    border-radius: 0.3rem;
    color: #faffff;
    background: #1fa3ec;
    line-height: 2.4rem;
    font-size: 1.2rem;
    width: 100%;
    transition-duration: 0.4s;
    cursor: pointer;
    margin: 5px 0px;
  }
  
  button:hover {
    background: #0e70a4;
  }
  
  .bred {
    background: #d43535;
  }

  .bred:hover {
    background: #931f1f;
  }
  </style>
</head>
<body>
  <a id="return_main_menu" href="index.htm">
    <svg height="24px" width="24px" viewBox="0 0 16 16" id="Layer_1">
      <path fill="white" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"/>
    </svg>
  </a>

  <h3>Deleting files or rebuilding the file list can take awhile. Reload this page to see an updated file list.</h3>

  <form id="delete_form" method="POST" action="delete"></form> <!-- delete using a list of files in a string -->
  <!--form id="delete_form" method="POST" onsubmit="event.preventDefault(); post_data()"--> <!-- delete using a list of files in json -->
  <div id="container" class="grid-container">
    <div class="grid-item-button">
      <button id="delete_btn" type="submit" form="delete_form" class="bred">Queue File(s) For Deletion</button>
    </div>

    <div id="checkbox_div"></div>

    <div class="grid-item-button">
      <button id="delete_btn" type="submit" form="delete_form" class="bred">Queue File(s) For Deletion</button>
    </div>
    <div class="grid-item-button">
      <br><br>
      <h7>Rebuilding the file list is only necessary if the file list becomes out of sync with the actual file system contents because of power loss or crash.</h7>
      <button id="rebuild_btn" onclick="request_rebuild()">Rebuild File List</button>
    </div>
  </div>

  <script>
  // minifier code breaks code when some escape sequences (e.g. backslash n) are used
  const newline_char = String.fromCharCode(10);
  const return_char = String.fromCharCode(13);
  //const tab_char = String.fromCharCode(9)

  base_url = "";
  if (window.location.protocol == "file:") {
    // makes for easier debugging.
    // if html is loaded locally, can see the results of editing more easily.
    // otherwise every change to html would require uploading new version to microcontroller.
    base_url = "http://pixelart.local";
  }

  /*
  async function post_data() {
    const marked_files = document.querySelectorAll('input[type="checkbox"]:checked');
    
    let delete_files = {};
    for (mf of marked_files) {
      const type = mf.getAttribute("data-type");
      const id = mf.getAttribute("data-id");
      if (!Array.isArray(delete_files[type])) {
        delete_files[type] = []; 
      }
      if (delete_files[type][0] != "") {
        // [""] means delete everything in directory so no point in adding individual files to list
        delete_files[type].push(id);
      }
    }

    console.log(JSON.stringify(delete_files));
    const response = await fetch(base_url+"/delete", {method: "POST", body: JSON.stringify(delete_files)});
  }
  */


  let url_string = "";
  function create_checkbox(root, type, id, size) {
    let path = root + "/" + type + "/" + id;
    if (!path.endsWith("/")) {
      path += ".json";
    }
    
    let name = type;
    if (id != "") {
      name += "/"+id;
    }

    let row = document.createElement("div");
    row.classList.add("grid-checkbox-row");
    let checkbox_input = document.createElement("input");
    checkbox_input.setAttribute("type", "checkbox");
    checkbox_input.setAttribute("id", path);
    checkbox_input.setAttribute("name", name);
    checkbox_input.setAttribute("data-type", type);
    checkbox_input.setAttribute("data-id", id);
    checkbox_input.setAttribute("data-size", size);
    checkbox_input.setAttribute("form", "delete_form");
  
    row.appendChild(checkbox_input);

    let label_anchor = document.createElement("a");
  
    let label_text = path;
    if (!path.endsWith("/")) {
      label_anchor.classList.add("span-regular-file");
      label_href = base_url+encodeURIComponent(label_text).replaceAll("%2F", "/");
      label_anchor.href = label_href;
      //label_text = "├──"+label_text;
      //label_text = "\\___"+label_text;
      if (size) {
        label_text += ` (${size} bytes)`;
      }

      if (!base_url) {
        url_string += `http://${location.hostname}`;
      }
      url_string += `${label_href} `;
    }
    label_anchor.appendChild(document.createTextNode(label_text));
    
    if (path.endsWith("/")) {
      //label_anchor.style.whiteSpace = "pre";
      const span = document.createElement('span');
      span.style.whiteSpace = "pre";
      span.textContent = '    (delete all files in folder, but keep folder)';
      span.style.color = 'gray';
      span.style.fontStyle = 'italic';
      label_anchor.appendChild(span);
    }

    row.appendChild(label_anchor);
    return row;
  }


  function sort_nested_object(obj) {
    if (typeof obj === "object" && obj !== null) {
      const sorted = {};
      Object.keys(obj).sort().forEach(key => {
        sorted[key] = sort_nested_object(obj[key]);
      });
      return sorted;
    }
    return obj; // primitive value
  }


  function insert_file_list(files) {
    let container = document.getElementById("container");
    let form = document.getElementById("delete_form");
    let insert_point = document.getElementById("insert_file_list_before_here");

    let checkbox_div = document.getElementById("checkbox_div");

    let num_files_added = 0;
    if (files) {
      files = sort_nested_object(files);
      const FILE_ROOT = Object.keys(files)[0];

      Object.keys(files[FILE_ROOT]).forEach(type => {
        let checkbox_row = create_checkbox(FILE_ROOT, type, "", -1);
        checkbox_div.appendChild(checkbox_row);
        Object.keys(files[FILE_ROOT][type]).forEach(id => {
          let size = files[FILE_ROOT][type][id];
          let checkbox_row = create_checkbox(FILE_ROOT, type, id, size);
          checkbox_div.appendChild(checkbox_row);
          num_files_added++;
        });        
      });

      // alternate method of backing up data by downloading each json file individually
      if (url_string) {
        console.log("wget --force-directories --wait=2 --limit-rate=20k "+url_string);
      }
    }
    
    if (num_files_added === 0) {
      let not_found_div = document.createElement("div");
      not_found_div.innerText = "No files found.";
      not_found_div.style = "color: white; text-align: center; width: 100%;";
      container.insertBefore(not_found_div, insert_point);
    }
    container.style.visibility = "visible";
  }
  
  
  async function request_rebuild() {
    // rebuilding file list takes multiple seconds, so no outcome message is expected
    try {
      let response = await fetch(`${base_url}/rebuild_file_list`);
      if (!response.ok) {
        throw new Error("Error fetching /rebuild_file_list");
      }
    }
    catch(e) {
      console.error(e);
    }
  }


  function convert_to_object(file_list_string) {
    let output = {};
    if (file_list_string.length === 0 || !file_list_string.startsWith("ROOT:")) {
      return output;
    }
    // guard against return and newline being used to separate lines.
    file_list_lines = file_list_string.replaceAll(return_char + newline_char, newline_char).split(newline_char);
    let FILE_ROOT = file_list_lines.shift();
    FILE_ROOT = FILE_ROOT.slice(5);

    output[FILE_ROOT] = {};

    for (let i = 0; i < file_list_lines.length; i++) {
      if (file_list_lines[i].endsWith("/")) {
        const type = file_list_lines[i].slice(0, -1);
        output[FILE_ROOT][type] = {};
        continue;
      }
      const si = file_list_lines[i].indexOf("/");
      if (si == -1) {
        continue; // bad entry
      }
      const type = file_list_lines[i].substring(0, si);
      const id = file_list_lines[i].substring(si+1);
      output[FILE_ROOT][type][id] = 0;
    }
    return output;
  }


  async function run() {
    let files;
    try {
      let response = await fetch(`${base_url}/file_list`);
      if (!response.ok) {
        throw new Error("Error fetching /file_list");
      }

      // a lot of html and javascript was already written for processing json file lists but it was
      // decided that using a text file list would keep things simpler in the microcontroller code.
      // converting a text file list to an object, so it can be processed using code already written
      // for processing a json /file_list. this leaves option the option open for returning to a json
      // file list in the microcontroller code in the future.
      response_text = await response.text();
      files = convert_to_object(response_text);

      //files = await response.json();

      if (Object.keys(files).length === 0 && files.constructor === Object) {
        throw new Error("Error file list is empty.");
      }
    }
    catch(e) {
      console.error(e);
      files = null; // files = {}; if (files) is true so use null
      // this is not a fatal error. device can still operate normally without any files.
    }

    insert_file_list(files);
  }

  window.addEventListener("load", run);

  </script>
</body>
</html>
